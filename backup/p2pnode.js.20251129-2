#!/usr/bin/env node

/**
 * P2P 3.0 â€” íŒŒì¼ + í´ë” ì „ì†¡ ì‹œìŠ¤í…œ
 *
 * - ì»¨íŠ¸ë¡¤ ì„œë²„ëŠ” ì–‘ìª½ì—ì„œ í•­ìƒ ì‹¤í–‰ (--control)
 * - ì–´ëŠ ë…¸ë“œì—ì„œ ëª…ë ¹ì„ ë‚´ë ¤ë„ A â†’ B, B â†’ A ì „ì†¡ ê°€ëŠ¥ (--send)
 * - source-host: ì‹¤ì œ íŒŒì¼/í´ë”ê°€ ìˆëŠ” ë…¸ë“œ
 * - target-host: ì‹¤ì œë¡œ íŒŒì¼ì„ ë°›ì•„ ì €ì¥í•  ë…¸ë“œ
 *
 * í´ë” ì „ì†¡ ê·œì¹™:
 *   - -t   : tarë¡œ ë¬¶ì–´ì„œ ì „ì†¡
 *   - -g   : íŒŒì¼ì´ë©´ .gz, í´ë”ë©´ .tar.gz
 *   - -tg  : tar.gz ë¡œ ì „ì†¡
 *   - ì—†ìŒ : í´ë” RAW ì „ì†¡ (ì••ì¶•/ë¬¶ìŒ ì—†ì´ êµ¬ì¡° ê·¸ëŒ€ë¡œ, ìµœìƒìœ„ í´ë” í¬í•¨)
 *
 * -norelease:
 *   - ì••ì¶• ì „ì†¡ì¼ ë•Œ tar/gz/tar.gzë¥¼ ìë™ í•´ì œí•˜ì§€ ì•Šê³  ê·¸ëŒ€ë¡œ ë‘ 
 */

const express = require("express");
const axios = require("axios");
const fs = require("fs");
const path = require("path");
const tar = require("tar");
const zlib = require("zlib");

// -------------------------------------------
// Utils
// -------------------------------------------
function fileExists(p) {
    try { fs.accessSync(p); return true; }
    catch { return false; }
}

function ensureDir(dir) {
    if (!fileExists(dir)) fs.mkdirSync(dir, { recursive: true });
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function drawProgress(downloaded, total) {
    if (!total) return;
    const ratio = downloaded / total;
    const percent = Math.floor(ratio * 100);
    const width = 40;
    const filled = Math.floor(ratio * width);
    const bar = "â–ˆ".repeat(filled) + "-".repeat(width - filled);
    process.stdout.write(`\r[${bar}] ${percent}% (${downloaded}/${total})`);
    if (downloaded >= total) process.stdout.write("\n");
}

async function autoExtractArchive(archivePath) {
    const base = path.basename(archivePath);
    const dir = path.dirname(archivePath);

    // .tar.gz / .tgz
    if (base.endsWith(".tar.gz") || base.endsWith(".tgz")) {
        console.log(`[CONTROL:DOWNLOAD] tar.gz í•´ì œ: ${archivePath}`);
        await tar.x({
            file: archivePath,
            cwd: dir,
            gzip: true
        });
        fs.unlinkSync(archivePath);
        return;
    }

    // .tar
    if (base.endsWith(".tar")) {
        console.log(`[CONTROL:DOWNLOAD] tar í•´ì œ: ${archivePath}`);
        await tar.x({
            file: archivePath,
            cwd: dir,
            gzip: false
        });
        fs.unlinkSync(archivePath);
        return;
    }

    // .gz (ë‹¨ì¼ íŒŒì¼)
    if (base.endsWith(".gz")) {
        console.log(`[CONTROL:DOWNLOAD] gz í•´ì œ: ${archivePath}`);
        const dest = archivePath.replace(/\.gz$/, "");
        await new Promise((resolve, reject) => {
            const rs = fs.createReadStream(archivePath);
            const ws = fs.createWriteStream(dest);
            const gunzip = zlib.createGunzip();
            rs.pipe(gunzip).pipe(ws);
            ws.on("finish", resolve);
            ws.on("error", reject);
            rs.on("error", reject);
            gunzip.on("error", reject);
        });
        fs.unlinkSync(archivePath);
        return;
    }

    // ê¸°íƒ€ í™•ì¥ìëŠ” ê±´ë“œë¦¬ì§€ ì•ŠìŒ
}

async function downloadToFileWithRetry(url, destPath, showProgress, label) {
    const MAX_RETRY = 5;

    for (let attempt = 1; attempt <= MAX_RETRY; attempt++) {
        try {
            const resp = await axios.get(url, { responseType: "stream" });

            const total = parseInt(resp.headers["content-length"] || "0", 10);
            let downloaded = 0;

            const ws = fs.createWriteStream(destPath);

            await new Promise((resolve, reject) => {
                resp.data.on("data", chunk => {
                    downloaded += chunk.length;
                    if (showProgress && total) drawProgress(downloaded, total);
                });
                resp.data.on("error", reject);
                ws.on("error", reject);
                ws.on("finish", resolve);

                resp.data.pipe(ws);
            });

            return; // ì„±ê³µ
        } catch (err) {
            console.warn(`[DOWNLOAD] ì‹¤íŒ¨(${attempt}): ${label || destPath} â†’ ${err.message}`);
            if (attempt >= MAX_RETRY) throw err;
            await sleep(500);
        }
    }
}

// ë””ë ‰í† ë¦¬ ì „ì²´ íŒŒì¼ ë¦¬ìŠ¤íŠ¸ (ìƒëŒ€ê²½ë¡œ)
function walkDir(baseDir) {
    const result = [];
    function walk(cur, rel) {
        const entries = fs.readdirSync(cur, { withFileTypes: true });
        for (const e of entries) {
            const full = path.join(cur, e.name);
            const relPath = rel ? path.join(rel, e.name) : e.name;
            if (e.isDirectory()) {
                walk(full, relPath);
            } else if (e.isFile()) {
                result.push(relPath);
            }
        }
    }
    walk(baseDir, "");
    return result;
}

// ì•„ì¹´ì´ë¸Œ ìƒì„±
async function prepareArchive(inputPath, packMode) {
    // packMode: none | tar | gz | targz
    const stat = fs.statSync(inputPath);
    const isDir = stat.isDirectory();
    const base = path.basename(inputPath);
    const tmpDir = require("os").tmpdir();

    if (packMode === "none") {
        return {
            archivePath: inputPath,
            archiveName: base,
            cleanup: false
        };
    }

    let outPath;

    if (isDir) {
        if (packMode === "tar") {
            outPath = path.join(tmpDir, `${base}.tar`);
            console.log(`[ARCHIVE] í´ë” tar ìƒì„±: ${outPath}`);
            await tar.c(
                {
                    file: outPath,
                    cwd: path.dirname(inputPath),
                    gzip: false
                },
                [base]
            );
        } else {
            // gz ë˜ëŠ” targz â†’ tar.gz
            outPath = path.join(tmpDir, `${base}.tar.gz`);
            console.log(`[ARCHIVE] í´ë” tar.gz ìƒì„±: ${outPath}`);
            await tar.c(
                {
                    file: outPath,
                    cwd: path.dirname(inputPath),
                    gzip: true
                },
                [base]
            );
        }
    } else {
        if (packMode === "tar") {
            outPath = path.join(tmpDir, `${base}.tar`);
            console.log(`[ARCHIVE] íŒŒì¼ tar ìƒì„±: ${outPath}`);
            await tar.c(
                {
                    file: outPath,
                    cwd: path.dirname(inputPath),
                    gzip: false
                },
                [base]
            );
        } else if (packMode === "targz") {
            outPath = path.join(tmpDir, `${base}.tar.gz`);
            console.log(`[ARCHIVE] íŒŒì¼ tar.gz ìƒì„±: ${outPath}`);
            await tar.c(
                {
                    file: outPath,
                    cwd: path.dirname(inputPath),
                    gzip: true
                },
                [base]
            );
        } else if (packMode === "gz") {
            outPath = path.join(tmpDir, `${base}.gz`);
            console.log(`[ARCHIVE] íŒŒì¼ gz ìƒì„±: ${outPath}`);
            await new Promise((resolve, reject) => {
                const rs = fs.createReadStream(inputPath);
                const ws = fs.createWriteStream(outPath);
                const gz = zlib.createGzip();
                rs.pipe(gz).pipe(ws);
                ws.on("finish", resolve);
                ws.on("error", reject);
                rs.on("error", reject);
                gz.on("error", reject);
            });
        } else {
            return {
                archivePath: inputPath,
                archiveName: base,
                cleanup: false
            };
        }
    }

    return {
        archivePath: outPath,
        archiveName: path.basename(outPath),
        cleanup: true
    };
}

// -------------------------------------------
// CONTROL SERVER (ì–‘ìª½ì—ì„œ í•­ìƒ ì‹¤í–‰)
// -------------------------------------------
async function startControlServer(port, host) {
    const app = express();
    app.use(express.json());

    console.log(`\ní ½í³¡ CONTROL SERVER RUNNING`);
    console.log(`  Host: ${host}`);
    console.log(`  Port: ${port}`);
    console.log(`  /api/download-file`);
    console.log(`  /api/download-folder-raw`);
    console.log(`  /api/send-file\n`);

    // health
    app.get("/api/health", (req, res) => {
        res.json({ status: "ok" });
    });

    /**
     * ë‹¨ì¼ íŒŒì¼/ì•„ì¹´ì´ë¸Œ ë‹¤ìš´ë¡œë“œ
     * body: { url, fileName, saveDir, progress, autoExtract }
     */
    app.post("/api/download-file", async (req, res) => {
        const { url, fileName, saveDir, progress, autoExtract } = req.body || {};

        if (!url || !fileName) {
            return res.status(400).json({ error: "url, fileName í•„ìˆ˜" });
        }

        const destDir = saveDir ? path.resolve(saveDir) : process.cwd();
        ensureDir(destDir);
        const destPath = path.join(destDir, fileName);

        console.log(`\n[CONTROL:DOWNLOAD] ë‹¨ì¼ íŒŒì¼`);
        console.log(`  URL  : ${url}`);
        console.log(`  Dest : ${destPath}`);
        console.log(`  autoExtract: ${autoExtract ? "ON" : "OFF"}`);

        try {
            await downloadToFileWithRetry(url, destPath, !!progress, fileName);

            if (autoExtract) {
                await autoExtractArchive(destPath);
            }

            console.log(`[CONTROL:DOWNLOAD] ì™„ë£Œ`);
            return res.status(200).json({ status: "ok", saved: destPath });
        } catch (err) {
            console.error(`[CONTROL:DOWNLOAD] ì‹¤íŒ¨: ${err.message}`);
            return res.status(500).json({ error: err.message });
        }
    });

    /**
     * RAW í´ë” ë‹¤ìš´ë¡œë“œ
     * body: { baseUrl, saveDir, progress }
     *
     * baseUrl: "http://sourceHost:dataPort"
     *  - GET {baseUrl}/list   â†’ { rootName, files }
     *  - GET {baseUrl}/download?file=...  íŒŒì¼ë³„
     */
    app.post("/api/download-folder-raw", async (req, res) => {
        const { baseUrl, saveDir, progress } = req.body || {};
        if (!baseUrl) {
            return res.status(400).json({ error: "baseUrl í•„ìˆ˜" });
        }

        console.log(`\n[CONTROL:FOLDER] RAW í´ë” ë‹¤ìš´ë¡œë“œ`);
        console.log(`  baseUrl : ${baseUrl}`);

        try {
            const listResp = await axios.get(`${baseUrl}/list`);
            const { rootName, files } = listResp.data;

            if (!rootName || !Array.isArray(files)) {
                throw new Error("list ì‘ë‹µ í˜•ì‹ ì˜¤ë¥˜");
            }

            const destRootParent = saveDir ? path.resolve(saveDir) : process.cwd();
            const destRoot = path.join(destRootParent, rootName);
            ensureDir(destRoot);

            console.log(`  rootName: ${rootName}`);
            console.log(`  íŒŒì¼ ê°œìˆ˜: ${files.length}`);
            console.log(`  ì €ì¥ ë£¨íŠ¸: ${destRoot}`);

            for (const rel of files) {
                const destPath = path.join(destRoot, rel);
                ensureDir(path.dirname(destPath));
                const url = `${baseUrl}/download?file=${encodeURIComponent(rel)}`;

                console.log(`  â†’ ${rel}`);
                await downloadToFileWithRetry(url, destPath, false, rel);
            }

            console.log(`[CONTROL:FOLDER] RAW í´ë” ë‹¤ìš´ë¡œë“œ ì™„ë£Œ`);
            return res.status(200).json({ status: "ok", savedRoot: destRoot, count: files.length });
        } catch (err) {
            console.error(`[CONTROL:FOLDER] ì‹¤íŒ¨: ${err.message}`);
            return res.status(500).json({ error: err.message });
        }
    });

    /**
     * ì´ ë…¸ë“œ(source-host)ì—ì„œ íŒŒì¼/í´ë”ë¥¼ ì „ì†¡í•˜ëŠ” API
     * body:
     *  {
     *    filePath,
     *    dataPort,
     *    sourceHost,
     *    targetHost,
     *    targetCtrlPort,
     *    targetSave,
     *    progress,
     *    packMode,      // none | tar | gz | targz
     *    autoExtract    // true/false (targetì—ì„œ)
     *  }
     */
    app.post("/api/send-file", async (req, res) => {
        const {
            filePath,
            dataPort,
            sourceHost,
            targetHost,
            targetCtrlPort,
            targetSave,
            progress,
            packMode,
            autoExtract
        } = req.body || {};

        if (!filePath || !sourceHost || !targetHost) {
            return res.status(400).json({ error: "filePath, sourceHost, targetHost í•„ìˆ˜" });
        }

        const resolvedPath = path.resolve(filePath);
        if (!fileExists(resolvedPath)) {
            return res.status(400).json({ error: `file not found: ${resolvedPath}` });
        }

        const stat = fs.statSync(resolvedPath);
        const isDir = stat.isDirectory();
        const isFile = stat.isFile();
        const portData = dataPort || 9000;
        const targetPort = targetCtrlPort || port;
        const mode = packMode || "none";

        if (!isDir && !isFile) {
            return res.status(400).json({ error: "filePathëŠ” íŒŒì¼ ë˜ëŠ” ë””ë ‰í† ë¦¬ì—¬ì•¼ í•¨" });
        }

        console.log(`\n[CONTROL:SEND] ì „ì†¡ ìš”ì²­`);
        console.log(`  path   : ${resolvedPath}`);
        console.log(`  isDir  : ${isDir}`);
        console.log(`  mode   : ${mode}`);
        console.log(`  src    : ${sourceHost}:${portData}`);
        console.log(`  target : ${targetHost}:${targetPort}`);
        console.log(`  save   : ${targetSave || "(target current dir)"}`);
        console.log(`  autoExtract: ${autoExtract ? "ON" : "OFF"}`);

        // ---- 1) RAW í´ë” ëª¨ë“œ ----
        if (isDir && mode === "none") {
            const baseDir = resolvedPath;
            const rootName = path.basename(baseDir);

            const dataApp = express();

            // /list â†’ { rootName, files[] }
            dataApp.get("/list", (req2, res2) => {
                try {
                    const files = walkDir(baseDir);
                    res2.json({ rootName, files });
                } catch (e) {
                    res2.status(500).json({ error: e.message });
                }
            });

            // /download?file=ìƒëŒ€ê²½ë¡œ
            dataApp.get("/download", (req2, res2) => {
                const rel = req2.query.file;
                if (!rel) {
                    return res2.status(400).send("file query required");
                }
                const safeRel = rel.replace(/\\/g, "/");
                const full = path.join(baseDir, safeRel);
                const resolved = path.resolve(full);
                if (!resolved.startsWith(path.resolve(baseDir))) {
                    return res2.status(400).send("invalid path");
                }
                if (!fileExists(resolved) || !fs.statSync(resolved).isFile()) {
                    return res2.status(404).send("not found");
                }
                const size = fs.statSync(resolved).size;

                res2.setHeader("Content-Type", "application/octet-stream");
                res2.setHeader("Content-Length", size);
                res2.setHeader("Content-Disposition",
                    `attachment; filename="${path.basename(resolved)}"`);

                const rs = fs.createReadStream(resolved);
                rs.on("error", err => {
                    console.error("[DATA:RAW] Read error:", err.message);
                    res2.destroy(err);
                });
                rs.pipe(res2);
            });

            const dataServer = dataApp.listen(portData, "0.0.0.0", async () => {
                console.log(`[DATA:RAW] í´ë” RAW ì„œë²„ ON â†’ http://${sourceHost}:${portData}`);

                const baseUrl = `http://${sourceHost}:${portData}`;
                const targetCtrlUrl = `http://${targetHost}:${targetPort}/api/download-folder-raw`;

                try {
                    const resp = await axios.post(targetCtrlUrl, {
                        baseUrl,
                        saveDir: targetSave,
                        progress
                    }, { timeout: 0 });

                    console.log(`[CONTROL:SEND] ëŒ€ìƒ ì‘ë‹µ:`, resp.data);
                    res.status(200).json({ status: "ok", detail: resp.data });
                } catch (err) {
                    console.error(`[CONTROL:SEND] RAW í´ë” ì „ì†¡ ì‹¤íŒ¨: ${err.message}`);
                    res.status(500).json({ error: err.message });
                } finally {
                    console.log(`[DATA:RAW] ì„œë²„ ì¢…ë£Œ`);
                    dataServer.close();
                }
            });

            return;
        }

        // ---- 2) ë‹¨ì¼ íŒŒì¼ / ì•„ì¹´ì´ë¸Œ ëª¨ë“œ ----
        let archivePath = resolvedPath;
        let archiveName = path.basename(resolvedPath);
        let cleanup = false;

        if (mode !== "none") {
            const prep = await prepareArchive(resolvedPath, mode);
            archivePath = prep.archivePath;
            archiveName = prep.archiveName;
            cleanup = prep.cleanup;
        }

        const size = fs.statSync(archivePath).size;

        const dataApp = express();

        dataApp.get("/download", (req2, res2) => {
            console.log(`[DATA] /download ìš”ì²­ ìˆ˜ì‹  â†’ ${archivePath}`);

            res2.setHeader("Content-Type", "application/octet-stream");
            res2.setHeader("Content-Disposition", `attachment; filename="${archiveName}"`);
            res2.setHeader("Content-Length", size);

            const rs = fs.createReadStream(archivePath);
            rs.on("error", err => {
                console.error("[DATA] Read error:", err.message);
                res2.destroy(err);
            });
            rs.pipe(res2);
        });

        const dataServer = dataApp.listen(portData, "0.0.0.0", async () => {
            console.log(`[DATA] ë‹¨ì¼ íŒŒì¼/ì•„ì¹´ì´ë¸Œ ì„œë²„ ON â†’ http://${sourceHost}:${portData}/download`);

            const downloadUrl = `http://${sourceHost}:${portData}/download`;
            const targetCtrlUrl = `http://${targetHost}:${targetPort}/api/download-file`;

            try {
                const resp = await axios.post(targetCtrlUrl, {
                    url: downloadUrl,
                    fileName: archiveName,
                    saveDir: targetSave,
                    progress,
                    autoExtract: !!autoExtract
                }, { timeout: 0 });

                console.log(`[CONTROL:SEND] ëŒ€ìƒ ì‘ë‹µ:`, resp.data);
                res.status(200).json({ status: "ok", detail: resp.data });
            } catch (err) {
                console.error(`[CONTROL:SEND] ë‹¨ì¼ íŒŒì¼ ì „ì†¡ ì‹¤íŒ¨: ${err.message}`);
                res.status(500).json({ error: err.message });
            } finally {
                console.log(`[DATA] ì„œë²„ ì¢…ë£Œ`);
                dataServer.close();
                if (cleanup && fileExists(archivePath)) {
                    fs.unlinkSync(archivePath);
                }
            }
        });
    });

    app.listen(port, host);
}

// -------------------------------------------
// SEND MODE (ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°)
// -------------------------------------------
async function startSendMode(opt) {
    const {
        sourceHost,
        sourceFile,
        sourceCtrlPort,
        sendPort,
        targetHost,
        targetCtrlPort,
        targetSave,
        progress,
        packMode,
        autoExtract
    } = opt;

    const controlUrl = `http://${sourceHost}:${sourceCtrlPort}/api/send-file`;

    console.log(`\n[SEND] ì „ì†¡ ëª…ë ¹ ì‹œì‘`);
    console.log(`  source-host(ctrl) : ${sourceHost}:${sourceCtrlPort}`);
    console.log(`  target-host(ctrl) : ${targetHost}:${targetCtrlPort}`);
    console.log(`  file/folder       : ${sourceFile}`);
    console.log(`  sendPort(data)    : ${sendPort}`);
    console.log(`  packMode          : ${packMode}`);
    console.log(`  autoExtract       : ${autoExtract ? "ON" : "OFF"}`);
    console.log(`  targetSave        : ${targetSave || "(target current dir)"}`);

    try {
        const resp = await axios.post(controlUrl, {
            filePath: sourceFile,
            dataPort: sendPort,
            sourceHost,
            targetHost,
            targetCtrlPort,
            targetSave,
            progress,
            packMode,
            autoExtract
        }, { timeout: 0 });

        console.log(`\n[SEND] ì™„ë£Œ ì‘ë‹µ:`, resp.data);
    } catch (err) {
        console.error(`\n[SEND] ì‹¤íŒ¨: ${err.message}`);
    }
}

// -------------------------------------------
// CLI Parser
// -------------------------------------------
function parseArgs(argv) {
    const out = {};
    for (let i = 0; i < argv.length; i++) {
        const a = argv[i];
        if (a.startsWith("--")) {
            const key = a.slice(2);
            const next = argv[i + 1];
            if (!next || next.startsWith("-")) out[key] = true;
            else { out[key] = next; i++; }
        } else if (a.startsWith("-")) {
            const key = a.slice(1);
            const next = argv[i + 1];
            if (!next || next.startsWith("-")) out[key] = true;
            else { out[key] = next; i++; }
        }
    }
    return out;
}

// -------------------------------------------
// ENTRY
// -------------------------------------------
(async () => {
    const args = parseArgs(process.argv.slice(2));

    // CONTROL ëª¨ë“œ
    if (args.control) {
        const host = args.h || args.host || "0.0.0.0";
        const port = parseInt(args.p || args.port || 7000, 10);
        await startControlServer(port, host);
        return;
    }

    // SEND ëª¨ë“œ
    if (args.send) {
        const sourceHost      = args["source-host"] || args["send-host"] || "127.0.0.1";
        const sourceFile      = args["source-file"] || args.f;
        const sourceCtrlPort  = parseInt(args["source-port"] || 7000, 10);
        const sendPort        = parseInt(args["send-port"] || 9000, 10);

        const targetHost      = args["target-host"] || args["client-host"];
        const targetCtrlPort  = parseInt(args["target-port"] || args["client-port"] || 7000, 10);
        const targetSave      = args["target-save"] || args["client-save"];
        const progress        = !!(args.b || args.progress);

        const hasT            = !!args.t;
        const hasG            = !!args.g;
        const hasTG           = !!args["tg"];
        const noRelease       = !!args["norelease"];

        if (!sourceFile) {
            console.error("Error: --source-file ë˜ëŠ” -f <íŒŒì¼ ë˜ëŠ” í´ë” ê²½ë¡œ> ê°€ í•„ìš”í•©ë‹ˆë‹¤.");
            process.exit(1);
        }
        if (!targetHost) {
            console.error("Error: --target-host <IP> ê°€ í•„ìš”í•©ë‹ˆë‹¤.");
            process.exit(1);
        }

        // packMode ê²°ì •
        let packMode = "none";
        if (hasTG || (hasT && hasG)) packMode = "targz";
        else if (hasT) packMode = "tar";
        else if (hasG) packMode = "gz";

        // autoExtract ê²°ì • (-norelease ê°€ ìˆìœ¼ë©´ í•´ì œ ì•ˆ í•¨)
        const autoExtract = !noRelease && packMode !== "none";

        await startSendMode({
            sourceHost,
            sourceFile,
            sourceCtrlPort,
            sendPort,
            targetHost,
            targetCtrlPort,
            targetSave,
            progress,
            packMode,
            autoExtract
        });
        return;
    }

    // ì‚¬ìš©ë²•
    console.log(`
ì‚¬ìš©ë²•:

1) ì»¨íŠ¸ë¡¤ ì„œë²„ (ì–‘ìª½ì—ì„œ ì‹¤í–‰)
   node p2pnode.js --control -p 7000 -h 0.0.0.0

2) ì „ì†¡ ëª…ë ¹ (íŒŒì¼ ë˜ëŠ” í´ë”)

   # A(192.168.79.9) â†’ B(192.168.146.131) ë¡œ ì „ì†¡
   # (ëª…ë ¹ì€ Aë“  Bë“  ì•„ë¬´ ê³³ì—ì„œë‚˜ ì‹¤í–‰ ê°€ëŠ¥)

   ## 1) íŒŒì¼/í´ë”ë¥¼ tar.gz ë¡œ ë³´ë‚´ê³ , ë°›ëŠ” ìª½ì—ì„œ ìë™ í•´ì œ
   node p2pnode.js --send \\
     --source-host 192.168.79.9 \\
     --source-file /root/testdir \\
     --send-port 9000 \\
     --source-port 7000 \\
     --target-host 192.168.146.131 \\
     --target-port 7000 \\
     --target-save /root/p2phttp/downloads \\
     -tg -b

   ## 2) ì••ì¶• ì—†ì´ í´ë” RAW ì „ì†¡ (ìµœìƒìœ„ í´ë” í¬í•¨)
   node p2pnode.js --send \\
     --source-host 192.168.79.9 \\
     --source-file /root/testdir \\
     --send-port 9000 \\
     --source-port 7000 \\
     --target-host 192.168.146.131 \\
     --target-port 7000 \\
     --target-save /root/p2phttp/downloads

   ## 3) ì••ì¶•ì€ í•˜ì§€ë§Œ í•´ì œëŠ” í•˜ì§€ ì•Šê¸° (-norelease)
   node p2pnode.js --send \\
     --source-host 192.168.79.9 \\
     --source-file /root/testdir \\
     --send-port 9000 \\
     --source-port 7000 \\
     --target-host 192.168.146.131 \\
     --target-port 7000 \\
     --target-save /root/p2phttp/downloads \\
     -tg -norelease -b

ì˜µì…˜ ì •ë¦¬:

  --control
    -p, --port          ì»¨íŠ¸ë¡¤ í¬íŠ¸ (ê¸°ë³¸ 7000)
    -h, --host          ë°”ì¸ë”© IP (ê¸°ë³¸ 0.0.0.0)

  --send
    --source-host       íŒŒì¼/í´ë”ê°€ ìˆëŠ” ë…¸ë“œ IP
    --source-file, -f   ì „ì†¡í•  íŒŒì¼ ë˜ëŠ” í´ë” ê²½ë¡œ
    --source-port       source-host ì»¨íŠ¸ë¡¤ í¬íŠ¸ (ê¸°ë³¸ 7000)
    --send-port         ë°ì´í„° ì„œë²„ í¬íŠ¸ (ê¸°ë³¸ 9000)

    --target-host       ë°›ì„ ë…¸ë“œ IP
    --target-port       target-host ì»¨íŠ¸ë¡¤ í¬íŠ¸ (ê¸°ë³¸ 7000)
    --target-save       target-hostê°€ ì €ì¥í•  ë””ë ‰í† ë¦¬

    -t                  tar ë¡œ ë¬¶ì–´ì„œ ì „ì†¡
    -g                  gzip ì••ì¶• (íŒŒì¼: .gz, í´ë”: .tar.gz)
    -tg                 tar.gz ë¡œ ì „ì†¡
    -norelease          ë°›ì€ ë’¤ ì••ì¶• í•´ì œí•˜ì§€ ì•ŠìŒ
    -b, --progress      ë‹¨ì¼ íŒŒì¼/ì•„ì¹´ì´ë¸Œ ì „ì†¡ ì‹œ ì§„í–‰ë¥  í‘œì‹œ
`);
})();

